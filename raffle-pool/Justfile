# Justfile for RPS Hook Deployment and Management
# Usage: just <command> [arguments]

# Default RPC URL (can be overridden with RPC_URL env var)
default-rpc-url := "http://localhost:8545"

# Default account name (can be overridden with ACCOUNT env var)
default-account := "default"

# Default private key for local Anvil (can be overridden with PRIVATE_KEY env var)
# This is Anvil's default first account private key
default-private-key := "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"

# Default sender address (can be overridden with SENDER env var)
# Note: Leave empty to not use --sender flag

# Deployments JSON file (stores all contract addresses)
deployments-file := "deployments.json"

# Chain ID (defaults to local Anvil)
chain-id := "31337"

# ============================================================================
# Default Command
# ============================================================================

# Show available commands
default:
    @just --list --unsorted

# ============================================================================
# Helper Functions
# ============================================================================

# Get address from deployments.json
# Usage: just _get-address <key>
_get-address KEY:
    #!/usr/bin/env bash
    if [ -f {{deployments-file}} ]; then
        jq -r ".contracts[\"{{KEY}}\"].address // empty" {{deployments-file}} 2>/dev/null || echo ""
    fi

# Set address in deployments.json (legacy - use _set-contract-metadata instead)
# Usage: just _set-address <key> <value>
_set-address KEY VALUE:
    #!/usr/bin/env bash
    if [ ! -f {{deployments-file}} ]; then
        echo '{"chainId": "{{chain-id}}", "rpcUrl": "{{default-rpc-url}}", "contracts": {}}' > {{deployments-file}}
    fi
    jq '.chainId = "{{chain-id}}" | .rpcUrl = (.rpcUrl // "{{default-rpc-url}}") | .contracts = (.contracts // {}) | .contracts["{{KEY}}"].address = "{{VALUE}}" | .contracts["{{KEY}}"].abi = (.contracts["{{KEY}}"].abi // []) | .contracts["{{KEY}}"].blockNumber = (.contracts["{{KEY}}"].blockNumber // 0)' {{deployments-file}} > {{deployments-file}}.tmp && mv {{deployments-file}}.tmp {{deployments-file}}

# Set contract metadata (ABI, blockNumber, etc.) in deployments.json
# Usage: just _set-contract-metadata <key> <address> <abi-path> <block-number>
_set-contract-metadata KEY ADDRESS ABI_PATH BLOCK_NUMBER:
    #!/usr/bin/env bash
    if [ ! -f {{deployments-file}} ]; then
        echo '{"chainId": "{{chain-id}}", "rpcUrl": "{{default-rpc-url}}", "contracts": {}}' > {{deployments-file}}
    fi
    
    # Ensure chainId, rpcUrl and contracts structure exists
    jq '.chainId = "{{chain-id}}" | .rpcUrl = (.rpcUrl // "{{default-rpc-url}}") | .contracts = (.contracts // {})' {{deployments-file}} > {{deployments-file}}.tmp && mv {{deployments-file}}.tmp {{deployments-file}}
    
    # Read ABI if file exists and is not empty
    ABI="[]"
    if [ -n "{{ABI_PATH}}" ] && [ "{{ABI_PATH}}" != "" ] && [ -f "{{ABI_PATH}}" ]; then
        ABI=$(jq -c '.abi' "{{ABI_PATH}}" 2>/dev/null || echo "[]")
    fi
    
    # Update deployments.json with contract info
    jq --arg key "{{KEY}}" \
       --arg addr "{{ADDRESS}}" \
       --argjson abi "$ABI" \
       --arg block "{{BLOCK_NUMBER}}" \
       '.contracts[$key] = {
         address: $addr,
         abi: $abi,
         blockNumber: ($block | tonumber)
       }' {{deployments-file}} > {{deployments-file}}.tmp && mv {{deployments-file}}.tmp {{deployments-file}}

# Extract address from broadcast JSON file
# Usage: just _extract-from-broadcast <script-name> <contract-name>
_extract-from-broadcast SCRIPT_NAME CONTRACT_NAME:
    #!/usr/bin/env bash
    BROADCAST_FILE="broadcast/{{SCRIPT_NAME}}/{{chain-id}}/run-latest.json"
    if [ -f "$BROADCAST_FILE" ]; then
        jq -r ".transactions[] | select(.contractName == \"{{CONTRACT_NAME}}\") | .contractAddress" "$BROADCAST_FILE" 2>/dev/null | head -1
    fi

# Load all addresses from deployments.json into environment
# Note: This function outputs export statements that should be eval'd or sourced
_load-addresses:
    #!/usr/bin/env bash
    if [ -f {{deployments-file}} ]; then
        echo "export HOOK_ADDRESS=$(jq -r '.contracts.hook.address // empty' {{deployments-file}} 2>/dev/null || echo '')"
        echo "export POOL_MANAGER_ADDRESS=$(jq -r '.contracts.poolManager.address // empty' {{deployments-file}} 2>/dev/null || echo '')"
        echo "export POSITION_MANAGER_ADDRESS=$(jq -r '.contracts.positionManager.address // empty' {{deployments-file}} 2>/dev/null || echo '')"
        echo "export ROUTER_ADDRESS=$(jq -r '.contracts.router.address // empty' {{deployments-file}} 2>/dev/null || echo '')"
        echo "export TOKEN0_ADDRESS=$(jq -r '.contracts.token0.address // empty' {{deployments-file}} 2>/dev/null || echo '')"
        echo "export TOKEN1_ADDRESS=$(jq -r '.contracts.token1.address // empty' {{deployments-file}} 2>/dev/null || echo '')"
        echo "export ROCK_PAPER_SCISSORS_ADDRESS=$(jq -r '.contracts.rockPaperScissors.address // empty' {{deployments-file}} 2>/dev/null || echo '')"
        echo "export VERIFIER_ADDRESS=$(jq -r '.contracts.verifier.address // empty' {{deployments-file}} 2>/dev/null || echo '')"
    fi

# ============================================================================
# Setup & Configuration
# ============================================================================

# Show all deployed addresses
show-addresses:
    #!/usr/bin/env bash
    if [ -f {{deployments-file}} ]; then
        echo "=== Deployed Contract Addresses ==="
        echo ""
        cat {{deployments-file}} | jq '.'
    else
        echo "No deployments found. Run deployment commands first."
    fi

# Copy deployments.json to frontend folder
copy-to-frontend:
    #!/usr/bin/env bash
    if [ ! -f {{deployments-file}} ]; then
        echo "Error: {{deployments-file}} not found. Run deployment commands first."
        exit 1
    fi
    FRONTEND_DIR="../pool-ui"
    if [ ! -d "$FRONTEND_DIR" ]; then
        echo "Error: Frontend directory not found at $FRONTEND_DIR"
        exit 1
    fi
    cp {{deployments-file}} "$FRONTEND_DIR/"
    echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"

# ============================================================================
# Deployment Commands
# ============================================================================

# Deploy test tokens for local development
# Usage: just deploy-tokens [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
deploy-tokens RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80":
    #!/usr/bin/env bash
    set -e
    
    # Extract parameters first (handle both direct calls and calls from setup)
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    
    # Strip parameter name prefix if present (e.g., "RPC_URL=value" -> "value")
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    
    # Remove any surrounding quotes (single or double) and trim whitespace
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Check if tokens are already deployed
    TOKEN0=$(just _get-address token0)
    TOKEN1=$(just _get-address token1)
    
    if [ -n "$TOKEN0" ] && [ -n "$TOKEN1" ]; then
        # Check if contracts have code at these addresses
        CODE0=$(cast code "$TOKEN0" --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
        CODE1=$(cast code "$TOKEN1" --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
        if [ -n "$CODE0" ] && [ -n "$CODE1" ] && [ "$CODE0" != "0x" ] && [ "$CODE1" != "0x" ]; then
            echo "✓ Tokens already deployed:"
            echo "  Token0: $TOKEN0"
            echo "  Token1: $TOKEN1"
            echo "Skipping token deployment."
            # Copy to frontend
            FRONTEND_DIR="../pool-ui"
            if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
                cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
            fi
            exit 0
        fi
    fi
    
    # Strip parameter name prefix if present (e.g., "RPC_URL=value" -> "value")
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    
    # Remove any surrounding quotes (single or double) and trim whitespace
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Validate private key format
    if [ -z "$PK_VAL" ] || [ "${#PK_VAL}" -ne 66 ] || [ "${PK_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid private key format. Expected 66 characters starting with 0x"
        echo "Got: [$PK_VAL] (length: ${#PK_VAL})"
        exit 1
    fi
    
    echo "Deploying test tokens..."
    forge script script/00_DeployTokens.s.sol \
        --rpc-url "$RPC_VAL" \
        --private-key "$PK_VAL" \
        --broadcast
    
    # Extract addresses from broadcast JSON
    echo ""
    echo "Extracting token addresses from broadcast files..."
    BROADCAST_FILE="broadcast/00_DeployTokens.s.sol/{{chain-id}}/run-latest.json"
    
    if [ ! -f "$BROADCAST_FILE" ]; then
        echo "⚠ Error: Broadcast file not found: $BROADCAST_FILE"
        exit 1
    fi
    
    # Debug: Show all transactions
    echo "  Debug: Transactions in token deployment broadcast file:"
    jq -r '.transactions[] | "    [\(.transactionType // "unknown")] \(.contractName // "null") -> \(.contractAddress // "null")"' "$BROADCAST_FILE" 2>/dev/null || echo "    Could not parse transactions"
    echo ""
    
    # Get all unique MockERC20 contract addresses from CREATE transactions
    # The script deploys token0 first, then token1, so they should be in order
    ALL_TOKEN_ADDRESSES=($(jq -r '.transactions[] | select(.contractName == "MockERC20" and (.transactionType == "CREATE" or .transactionType == "CREATE2")) | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | sort -u))
    
    if [ ${#ALL_TOKEN_ADDRESSES[@]} -lt 2 ]; then
        echo "⚠ ERROR: Expected 2 token addresses, but found ${#ALL_TOKEN_ADDRESSES[@]}"
        echo "  Found addresses: ${ALL_TOKEN_ADDRESSES[@]}"
        echo "  Please check the broadcast file: $BROADCAST_FILE"
        exit 1
    fi
    
    TOKEN0="${ALL_TOKEN_ADDRESSES[0]}"
    TOKEN1="${ALL_TOKEN_ADDRESSES[1]}"
    
    # Validate addresses are different
    if [ "$TOKEN0" = "$TOKEN1" ]; then
        echo "⚠ ERROR: Token0 and Token1 have the same address: $TOKEN0"
        echo "  This should not happen. Please check the deployment script."
        exit 1
    fi
    
    echo "  Extracted Token0: $TOKEN0"
    echo "  Extracted Token1: $TOKEN1"
    
    if [ -n "$TOKEN0" ] && [ -n "$TOKEN1" ] && [ "$TOKEN0" != "null" ] && [ "$TOKEN1" != "null" ]; then
        # Extract block numbers from broadcast file by matching transaction hash
        # Get the first transaction hash for each address
        HASH0=$(jq -r '.transactions[] | select(.contractName == "MockERC20" and .contractAddress == "'"$TOKEN0"'" and (.transactionType == "CREATE" or .transactionType == "CREATE2")) | .hash' "$BROADCAST_FILE" 2>/dev/null | head -1)
        HASH1=$(jq -r '.transactions[] | select(.contractName == "MockERC20" and .contractAddress == "'"$TOKEN1"'" and (.transactionType == "CREATE" or .transactionType == "CREATE2")) | .hash' "$BROADCAST_FILE" 2>/dev/null | head -1)
        
        BLOCK0=$(jq -r --arg hash "$HASH0" '.receipts[] | select(.transactionHash == $hash) | .blockNumber' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "0x0")
        BLOCK1=$(jq -r --arg hash "$HASH1" '.receipts[] | select(.transactionHash == $hash) | .blockNumber' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "0x0")
        
        # Convert hex to decimal
        BLOCK0=$(printf "%d" "$BLOCK0" 2>/dev/null || echo "0")
        BLOCK1=$(printf "%d" "$BLOCK1" 2>/dev/null || echo "0")
        
        # Save with metadata (ABI and block number)
        just _set-contract-metadata token0 "$TOKEN0" "out/MockERC20.sol/MockERC20.json" "$BLOCK0"
        just _set-contract-metadata token1 "$TOKEN1" "out/MockERC20.sol/MockERC20.json" "$BLOCK1"
        echo ""
        echo "✓ Token0 deployed at: $TOKEN0 (block: $BLOCK0)"
        echo "✓ Token1 deployed at: $TOKEN1 (block: $BLOCK1)"
        echo "✓ Addresses verified (different addresses)"
        echo "✓ Addresses and ABIs saved to {{deployments-file}}"
        # Copy to frontend
        FRONTEND_DIR="../pool-ui"
        if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
            cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
        fi
    else
        echo "⚠ Could not extract token addresses from broadcast files."
        echo "Please check broadcast/00_DeployTokens.s.sol/{{chain-id}}/run-latest.json"
    fi

# Deploy the RPS Hook contract
# Usage: just deploy-hook [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
deploy-hook RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters first
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    ACCOUNT_VAL="{{ACCOUNT}}"
    SENDER_VAL="{{SENDER}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    case "$ACCOUNT_VAL" in
        ACCOUNT=*)
            ACCOUNT_VAL="${ACCOUNT_VAL#ACCOUNT=}"
            ;;
    esac
    case "$SENDER_VAL" in
        SENDER=*)
            SENDER_VAL="${SENDER_VAL#SENDER=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    ACCOUNT_VAL=$(echo "$ACCOUNT_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    SENDER_VAL=$(echo "$SENDER_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Check if hook is already deployed
    HOOK_ADDR=$(just _get-address hook)
    if [ -n "$HOOK_ADDR" ]; then
        # Check if contract has code at this address
        CODE=$(cast code "$HOOK_ADDR" --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
        if [ -n "$CODE" ] && [ "$CODE" != "0x" ]; then
            echo "✓ Hook already deployed at: $HOOK_ADDR"
            echo "Skipping hook deployment."
            # Copy to frontend
            FRONTEND_DIR="../pool-ui"
            if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
                cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
            fi
            exit 0
        fi
    fi
    
    # Load PoolManager address if available
    POOL_MGR=$(just _get-address poolManager)
    if [ -n "$POOL_MGR" ]; then
        export POOL_MANAGER_ADDRESS=$POOL_MGR
    fi
    
    echo "Deploying RPS Hook..."
    
    # Build command array
    CMD_ARGS=("script/00_DeployHook.s.sol" "--rpc-url" "$RPC_VAL")
    
    # Only add --private-key if provided and not empty
    if [ -n "$PK_VAL" ] && [ "$PK_VAL" != "" ]; then
        CMD_ARGS+=("--private-key" "$PK_VAL")
    fi
    
    # Only add --account if provided, not empty, and not "default"
    if [ -n "$ACCOUNT_VAL" ] && [ "$ACCOUNT_VAL" != "" ] && [ "$ACCOUNT_VAL" != "default" ]; then
        CMD_ARGS+=("--account" "$ACCOUNT_VAL")
    fi
    
    # Only add --sender if provided and not empty
    if [ -n "$SENDER_VAL" ] && [ "$SENDER_VAL" != "" ] && [ "$SENDER_VAL" != "''" ]; then
        CMD_ARGS+=("--sender" "$SENDER_VAL")
    fi
    
    CMD_ARGS+=(--broadcast)
    
    # Run deployment
    forge script "${CMD_ARGS[@]}"
    
    # Extract hook address from broadcast JSON
    echo ""
    echo "Extracting hook address from broadcast files..."
    HOOK_ADDR=$(just _extract-from-broadcast 00_DeployHook.s.sol RPSHook)
    
    if [ -n "$HOOK_ADDR" ]; then
        # Extract block number from broadcast file
        BROADCAST_FILE="broadcast/00_DeployHook.s.sol/{{chain-id}}/run-latest.json"
        HASH=$(jq -r '.transactions[] | select(.contractName == "RPSHook" and .contractAddress == "'"$HOOK_ADDR"'") | .hash' "$BROADCAST_FILE" 2>/dev/null | head -1)
        BLOCK=$(jq -r --arg hash "$HASH" '.receipts[] | select(.transactionHash == $hash) | .blockNumber' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "0x0")
        BLOCK=$(printf "%d" "$BLOCK" 2>/dev/null || echo "0")
        
        # Save with metadata (ABI and block number)
        just _set-contract-metadata hook "$HOOK_ADDR" "out/RPSHook.sol/RPSHook.json" "$BLOCK"
        echo ""
        echo "✓ Hook deployed at: $HOOK_ADDR (block: $BLOCK)"
        echo "✓ Address and ABI saved to {{deployments-file}}"
        # Copy to frontend
        FRONTEND_DIR="../pool-ui"
        if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
            cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
        fi
    else
        echo "⚠ Could not extract hook address from broadcast files."
        echo "Please check broadcast/00_DeployHook.s.sol/{{chain-id}}/run-latest.json"
    fi

# Deploy the RockPaperScissors contract
# Usage: just deploy-rps [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
deploy-rps RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters first
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    ACCOUNT_VAL="{{ACCOUNT}}"
    SENDER_VAL="{{SENDER}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    case "$ACCOUNT_VAL" in
        ACCOUNT=*)
            ACCOUNT_VAL="${ACCOUNT_VAL#ACCOUNT=}"
            ;;
    esac
    case "$SENDER_VAL" in
        SENDER=*)
            SENDER_VAL="${SENDER_VAL#SENDER=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    ACCOUNT_VAL=$(echo "$ACCOUNT_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    SENDER_VAL=$(echo "$SENDER_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Check if contract is already deployed
    RPS_ADDR=$(just _get-address rockPaperScissors)
    if [ -n "$RPS_ADDR" ]; then
        # Check if this address conflicts with token addresses (indicates wrong address was saved)
        EXISTING_TOKEN0=$(just _get-address token0)
        EXISTING_TOKEN1=$(just _get-address token1)
        if [ "$RPS_ADDR" = "$EXISTING_TOKEN0" ] || [ "$RPS_ADDR" = "$EXISTING_TOKEN1" ]; then
            echo "⚠ Warning: RockPaperScissors address in deployments.json ($RPS_ADDR) conflicts with a token address!"
            echo "  This indicates a previous incorrect deployment. Forcing redeployment..."
            # Remove the incorrect entry
            jq 'del(.contracts.rockPaperScissors)' {{deployments-file}} > {{deployments-file}}.tmp && mv {{deployments-file}}.tmp {{deployments-file}}
            RPS_ADDR=""
        else
            # Check if contract has code at this address
            CODE=$(cast code "$RPS_ADDR" --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
            if [ -n "$CODE" ] && [ "$CODE" != "0x" ]; then
                # Verify it's actually a RockPaperScissors contract by checking for a unique function
                # Try to call a function that only exists on RockPaperScissors (like gameCounter)
                GAME_COUNTER=$(cast call "$RPS_ADDR" "gameCounter()(uint256)" --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
                if [ -n "$GAME_COUNTER" ]; then
                    echo "✓ RockPaperScissors already deployed at: $RPS_ADDR"
                    echo "Skipping deployment."
                    # Copy to frontend
                    FRONTEND_DIR="../pool-ui"
                    if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
                        cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
                    fi
                    exit 0
                else
                    echo "⚠ Warning: Address $RPS_ADDR has code but is not a RockPaperScissors contract!"
                    echo "  Forcing redeployment..."
                    # Remove the incorrect entry
                    jq 'del(.contracts.rockPaperScissors)' {{deployments-file}} > {{deployments-file}}.tmp && mv {{deployments-file}}.tmp {{deployments-file}}
                    RPS_ADDR=""
                fi
            fi
        fi
    fi
    
    # Get verifier address from deployments.json to pass to the deployment script
    VERIFIER_ADDR=$(just _get-address verifier)
    if [ -n "$VERIFIER_ADDR" ]; then
        export VERIFIER_ADDRESS=$VERIFIER_ADDR
        echo "Using verifier address: $VERIFIER_ADDR"
    else
        echo "⚠ Warning: No verifier address found in deployments.json"
        echo "  RockPaperScissors will be deployed without a verifier set"
        echo "  You can set it later by calling setVerifier() on the contract"
    fi
    
    echo "Deploying RockPaperScissors..."
    
    # Build command array
    CMD_ARGS=("script/DeployRockPaperScissors.s.sol" "--rpc-url" "$RPC_VAL")
    
    # Only add --private-key if provided and not empty
    if [ -n "$PK_VAL" ] && [ "$PK_VAL" != "" ]; then
        CMD_ARGS+=("--private-key" "$PK_VAL")
    fi
    
    # Only add --account if provided, not empty, and not "default"
    if [ -n "$ACCOUNT_VAL" ] && [ "$ACCOUNT_VAL" != "" ] && [ "$ACCOUNT_VAL" != "default" ]; then
        CMD_ARGS+=("--account" "$ACCOUNT_VAL")
    fi
    
    # Only add --sender if provided and not empty
    if [ -n "$SENDER_VAL" ] && [ "$SENDER_VAL" != "" ] && [ "$SENDER_VAL" != "''" ]; then
        CMD_ARGS+=("--sender" "$SENDER_VAL")
    fi
    
    CMD_ARGS+=(--broadcast)
    
    # Run deployment
    forge script "${CMD_ARGS[@]}"
    
    # Extract address from broadcast JSON
    echo ""
    echo "Extracting RockPaperScissors address from broadcast files..."
    BROADCAST_FILE="broadcast/DeployRockPaperScissors.s.sol/{{chain-id}}/run-latest.json"
    
    if [ ! -f "$BROADCAST_FILE" ]; then
        echo "⚠ Error: Broadcast file not found: $BROADCAST_FILE"
        exit 1
    fi
    
    # Verify we're reading from the correct broadcast file
    SCRIPT_NAME=$(jq -r '.transactions[0].transaction.contractName // .transactions[0].contractName // "unknown"' "$BROADCAST_FILE" 2>/dev/null || echo "unknown")
    echo "  Reading from broadcast file: $BROADCAST_FILE"
    
    # Debug: Show all transactions in the broadcast file
    echo "  Debug: Transactions in broadcast file:"
    jq -r '.transactions[] | "    [\(.transactionType // "unknown")] \(.contractName // "null") -> \(.contractAddress // "null")"' "$BROADCAST_FILE" 2>/dev/null || echo "    Could not parse transactions"
    echo ""
    
    # First, try to get the CREATE transaction with contractName "RockPaperScissors"
    # This is the actual deployment transaction (not the setVerifier call)
    RPS_ADDR=$(jq -r '.transactions[] | select(.contractName == "RockPaperScissors" and (.transactionType == "CREATE" or .transactionType == "CREATE2")) | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1)
    
    # Fallback 1: If contractName is set but transactionType filter didn't work, get first one
    if [ -z "$RPS_ADDR" ] || [ "$RPS_ADDR" = "null" ]; then
        RPS_ADDR=$(jq -r '.transactions[] | select(.contractName == "RockPaperScissors") | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1)
    fi
    
    # Fallback 2: If contractName is null or empty, try to find by transaction type only
    # Get the FIRST CREATE transaction (the deployment happens before setVerifier call)
    # IMPORTANT: Use head -1 to get the FIRST one, not the last one
    if [ -z "$RPS_ADDR" ] || [ "$RPS_ADDR" = "null" ]; then
        RPS_ADDR=$(jq -r '.transactions[] | select(.transactionType == "CREATE" or .transactionType == "CREATE2") | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1)
    fi
    
    echo "  Extracted address: $RPS_ADDR"
    
    # Verify the address is not already used by another contract
    if [ -n "$RPS_ADDR" ] && [ "$RPS_ADDR" != "null" ]; then
        # Check if this address is already recorded for a different contract
        EXISTING_TOKEN0=$(just _get-address token0)
        EXISTING_TOKEN1=$(just _get-address token1)
        
        if [ "$RPS_ADDR" = "$EXISTING_TOKEN0" ]; then
            echo "⚠ ERROR: Extracted RockPaperScissors address $RPS_ADDR matches Token0 address!"
            echo "  Token0: $EXISTING_TOKEN0"
            echo "  This indicates the address extraction is incorrect."
            echo ""
            echo "  Debugging info:"
            echo "  All transactions in RockPaperScissors broadcast file:"
            jq -r '.transactions[] | "    [\(.transactionType // "unknown")] \(.contractName // "null") -> \(.contractAddress // "null")"' "$BROADCAST_FILE" 2>/dev/null || echo "    Could not parse transactions"
            echo ""
            echo "  Please verify the broadcast file manually: $BROADCAST_FILE"
            echo "  The RockPaperScissors contract address should be in a CREATE transaction."
            exit 1
        fi
        
        if [ "$RPS_ADDR" = "$EXISTING_TOKEN1" ]; then
            echo "⚠ ERROR: Extracted RockPaperScissors address $RPS_ADDR matches Token1 address!"
            echo "  Token1: $EXISTING_TOKEN1"
            echo "  This indicates the address extraction is INCORRECT - you're getting Token1's address instead of RockPaperScissors!"
            echo ""
            echo "  Debugging info:"
            echo "  All transactions in RockPaperScissors broadcast file:"
            jq -r '.transactions[] | "    [\(.transactionType // "unknown")] \(.contractName // "null") -> \(.contractAddress // "null")"' "$BROADCAST_FILE" 2>/dev/null || echo "    Could not parse transactions"
            echo ""
            echo "  Possible causes:"
            echo "  1. The broadcast file path is wrong"
            echo "  2. The extraction logic is picking the wrong transaction"
            echo "  3. The contractName in the broadcast file is wrong"
            echo ""
            echo "  Please verify the broadcast file manually: $BROADCAST_FILE"
            echo "  Expected: A CREATE transaction with contractName='RockPaperScissors'"
            exit 1
        fi
    fi
    
    if [ -n "$RPS_ADDR" ] && [ "$RPS_ADDR" != "null" ]; then
        # Verify the address has contract code (basic sanity check)
        CODE=$(cast code "$RPS_ADDR" --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
        if [ -z "$CODE" ] || [ "$CODE" = "0x" ]; then
            echo "⚠ ERROR: Extracted address $RPS_ADDR has no contract code!"
            echo "  This suggests the address extraction is incorrect."
            echo "  Please verify the broadcast file manually: $BROADCAST_FILE"
            exit 1
        fi
        
        # Extract block number from broadcast file
        # Match the hash from the CREATE transaction (not the setVerifier call)
        HASH=$(jq -r '.transactions[] | select(.contractAddress == "'"$RPS_ADDR"'" and (.transactionType == "CREATE" or .transactionType == "CREATE2")) | .hash' "$BROADCAST_FILE" 2>/dev/null | head -1)
        # Fallback: if that doesn't work, just get the first hash for this address
        if [ -z "$HASH" ] || [ "$HASH" = "null" ]; then
            HASH=$(jq -r '.transactions[] | select(.contractAddress == "'"$RPS_ADDR"'") | .hash' "$BROADCAST_FILE" 2>/dev/null | head -1)
        fi
        BLOCK=$(jq -r --arg hash "$HASH" '.receipts[] | select(.transactionHash == $hash) | .blockNumber' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "0x0")
        BLOCK=$(printf "%d" "$BLOCK" 2>/dev/null || echo "0")
        
        # Save with metadata (ABI and block number)
        just _set-contract-metadata rockPaperScissors "$RPS_ADDR" "out/RockPaperScissors.sol/RockPaperScissors.json" "$BLOCK"
        echo ""
        echo "✓ RockPaperScissors deployed at: $RPS_ADDR (block: $BLOCK)"
        echo "✓ Address verified (has contract code)"
        echo "✓ Address and ABI saved to {{deployments-file}}"
        # Copy to frontend
        FRONTEND_DIR="../pool-ui"
        if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
            cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
        fi
    else
        echo "⚠ ERROR: Could not extract RockPaperScissors address from broadcast files!"
        echo ""
        echo "  Broadcast file: $BROADCAST_FILE"
        echo "  File exists: $([ -f "$BROADCAST_FILE" ] && echo "yes" || echo "no")"
        echo ""
        echo "  All transactions in broadcast file:"
        jq -r '.transactions[] | "    [\(.transactionType // "unknown")] \(.contractName // "null") -> \(.contractAddress // "null")"' "$BROADCAST_FILE" 2>/dev/null || echo "    Could not parse transactions"
        echo ""
        echo "  Attempted extraction methods:"
        echo "  1. CREATE transaction with contractName='RockPaperScissors': $(jq -r '.transactions[] | select(.contractName == "RockPaperScissors" and (.transactionType == "CREATE" or .transactionType == "CREATE2")) | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "none found")"
        echo "  2. Any transaction with contractName='RockPaperScissors': $(jq -r '.transactions[] | select(.contractName == "RockPaperScissors") | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "none found")"
        echo "  3. First CREATE transaction: $(jq -r '.transactions[] | select(.transactionType == "CREATE" or .transactionType == "CREATE2") | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "none found")"
        echo ""
        echo "  Please check the broadcast file manually and extract the correct address."
        echo "  The RockPaperScissors contract should be deployed in a CREATE transaction."
        exit 1
    fi

# Configure the Hook to use RockPaperScissors
# Usage: just configure-hook [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
configure-hook RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters first
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    ACCOUNT_VAL="{{ACCOUNT}}"
    SENDER_VAL="{{SENDER}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    case "$ACCOUNT_VAL" in
        ACCOUNT=*)
            ACCOUNT_VAL="${ACCOUNT_VAL#ACCOUNT=}"
            ;;
    esac
    case "$SENDER_VAL" in
        SENDER=*)
            SENDER_VAL="${SENDER_VAL#SENDER=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    ACCOUNT_VAL=$(echo "$ACCOUNT_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    SENDER_VAL=$(echo "$SENDER_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Get addresses from deployments.json
    HOOK_ADDR=$(just _get-address hook)
    RPS_ADDR=$(just _get-address rockPaperScissors)
    
    if [ -z "$HOOK_ADDR" ]; then
        echo "❌ Error: Hook address not found in deployments.json"
        echo "  Please deploy the hook first using: just deploy-hook"
        exit 1
    fi
    
    if [ -z "$RPS_ADDR" ]; then
        echo "❌ Error: RockPaperScissors address not found in deployments.json"
        echo "  Please deploy RockPaperScissors first using: just deploy-rps"
        exit 1
    fi
    
    # Check if already configured
    CURRENT_RPS=$(cast call "$HOOK_ADDR" "rockPaperScissors()(address)" --rpc-url "$RPC_VAL" 2>/dev/null || echo "0x0000000000000000000000000000000000000000")
    if [ "$CURRENT_RPS" != "0x0000000000000000000000000000000000000000" ]; then
        if [ "$(echo "$CURRENT_RPS" | tr '[:upper:]' '[:lower:]')" = "$(echo "$RPS_ADDR" | tr '[:upper:]' '[:lower:]')" ]; then
            echo "✓ Hook is already configured with RockPaperScissors at: $RPS_ADDR"
            exit 0
        else
            echo "⚠ Warning: Hook is already configured with a different RockPaperScissors address: $CURRENT_RPS"
            echo "  Cannot reconfigure (setRockPaperScissors can only be called once)"
            exit 1
        fi
    fi
    
    # Set environment variables for the script
    export HOOK_ADDRESS=$HOOK_ADDR
    export ROCK_PAPER_SCISSORS_ADDRESS=$RPS_ADDR
    
    echo "Configuring hook at $HOOK_ADDR"
    echo "  with RockPaperScissors at $RPS_ADDR"
    
    # Build command array
    CMD_ARGS=("script/ConfigureHook.s.sol" "--rpc-url" "$RPC_VAL")
    
    # Only add --private-key if provided and not empty
    if [ -n "$PK_VAL" ] && [ "$PK_VAL" != "" ]; then
        CMD_ARGS+=("--private-key" "$PK_VAL")
    fi
    
    # Only add --account if provided, not empty, and not "default"
    if [ -n "$ACCOUNT_VAL" ] && [ "$ACCOUNT_VAL" != "" ] && [ "$ACCOUNT_VAL" != "default" ]; then
        CMD_ARGS+=("--account" "$ACCOUNT_VAL")
    fi
    
    # Only add --sender if provided and not empty
    if [ -n "$SENDER_VAL" ] && [ "$SENDER_VAL" != "" ] && [ "$SENDER_VAL" != "''" ]; then
        CMD_ARGS+=("--sender" "$SENDER_VAL")
    fi
    
    CMD_ARGS+=(--broadcast)
    
    # Run configuration
    forge script "${CMD_ARGS[@]}"
    
    echo ""
    echo "✓ Hook configured successfully!"

# Deploy the Verifier contract
# Usage: just deploy-verifier [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
deploy-verifier RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters first
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    ACCOUNT_VAL="{{ACCOUNT}}"
    SENDER_VAL="{{SENDER}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    case "$ACCOUNT_VAL" in
        ACCOUNT=*)
            ACCOUNT_VAL="${ACCOUNT_VAL#ACCOUNT=}"
            ;;
    esac
    case "$SENDER_VAL" in
        SENDER=*)
            SENDER_VAL="${SENDER_VAL#SENDER=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    ACCOUNT_VAL=$(echo "$ACCOUNT_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    SENDER_VAL=$(echo "$SENDER_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Check if contract is already deployed
    VERIFIER_ADDR=$(just _get-address verifier)
    if [ -n "$VERIFIER_ADDR" ]; then
        # Check if this address conflicts with token addresses (indicates wrong address was saved)
        EXISTING_TOKEN0=$(just _get-address token0)
        EXISTING_TOKEN1=$(just _get-address token1)
        if [ "$VERIFIER_ADDR" = "$EXISTING_TOKEN0" ] || [ "$VERIFIER_ADDR" = "$EXISTING_TOKEN1" ]; then
            echo "⚠ Warning: Verifier address in deployments.json ($VERIFIER_ADDR) conflicts with a token address!"
            echo "  This indicates a previous incorrect deployment. Forcing redeployment..."
            # Remove the incorrect entry
            jq 'del(.contracts.verifier)' {{deployments-file}} > {{deployments-file}}.tmp && mv {{deployments-file}}.tmp {{deployments-file}}
            VERIFIER_ADDR=""
        else
            # Check if contract has code at this address
            CODE=$(cast code "$VERIFIER_ADDR" --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
            if [ -n "$CODE" ] && [ "$CODE" != "0x" ]; then
                # Verify it's actually a Verifier contract by trying to call a unique function
                # Try to call verify function (it will fail with wrong params, but that's ok - we just check it exists)
                # Actually simpler: check if it has the verify function by checking the ABI in deployments.json
                # Or even simpler: just check if it's NOT a token by trying to call a token function
                HAS_BALANCE=$(cast call "$VERIFIER_ADDR" "balanceOf(address)(uint256)" "0x0000000000000000000000000000000000000000" --rpc-url "$RPC_VAL" 2>/dev/null || echo "ERROR")
                if [ "$HAS_BALANCE" != "ERROR" ]; then
                    echo "⚠ Warning: Address $VERIFIER_ADDR appears to be a token contract (has balanceOf), not a Verifier!"
                    echo "  Forcing redeployment..."
                    # Remove the incorrect entry
                    jq 'del(.contracts.verifier)' {{deployments-file}} > {{deployments-file}}.tmp && mv {{deployments-file}}.tmp {{deployments-file}}
                    VERIFIER_ADDR=""
                else
                    echo "✓ Verifier already deployed at: $VERIFIER_ADDR"
                    echo "Skipping deployment."
                    # Copy to frontend
                    FRONTEND_DIR="../pool-ui"
                    if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
                        cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
                    fi
                    exit 0
                fi
            fi
        fi
    fi
    
    echo "Deploying Verifier..."
    
    # Build command array
    CMD_ARGS=("script/DeployVerifier.s.sol" "--rpc-url" "$RPC_VAL")
    
    # Only add --private-key if provided and not empty
    if [ -n "$PK_VAL" ] && [ "$PK_VAL" != "" ]; then
        CMD_ARGS+=("--private-key" "$PK_VAL")
    fi
    
    # Only add --account if provided, not empty, and not "default"
    if [ -n "$ACCOUNT_VAL" ] && [ "$ACCOUNT_VAL" != "" ] && [ "$ACCOUNT_VAL" != "default" ]; then
        CMD_ARGS+=("--account" "$ACCOUNT_VAL")
    fi
    
    # Only add --sender if provided and not empty
    if [ -n "$SENDER_VAL" ] && [ "$SENDER_VAL" != "" ] && [ "$SENDER_VAL" != "''" ]; then
        CMD_ARGS+=("--sender" "$SENDER_VAL")
    fi
    
    CMD_ARGS+=(--broadcast)
    
    # Run deployment
    forge script "${CMD_ARGS[@]}"
    
    # Extract address from broadcast JSON
    echo ""
    echo "Extracting Verifier address from broadcast files..."
    VERIFIER_ADDR=$(just _extract-from-broadcast DeployVerifier.s.sol HonkVerifier)
    
    if [ -n "$VERIFIER_ADDR" ]; then
        # Extract block number from broadcast file
        BROADCAST_FILE="broadcast/DeployVerifier.s.sol/{{chain-id}}/run-latest.json"
        HASH=$(jq -r '.transactions[] | select(.contractName == "HonkVerifier" and .contractAddress == "'"$VERIFIER_ADDR"'") | .hash' "$BROADCAST_FILE" 2>/dev/null | head -1)
        BLOCK=$(jq -r --arg hash "$HASH" '.receipts[] | select(.transactionHash == $hash) | .blockNumber' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "0x0")
        BLOCK=$(printf "%d" "$BLOCK" 2>/dev/null || echo "0")
        
        # Save with metadata (ABI and block number)
        just _set-contract-metadata verifier "$VERIFIER_ADDR" "out/Verifier.sol/HonkVerifier.json" "$BLOCK"
        echo ""
        echo "✓ Verifier deployed at: $VERIFIER_ADDR (block: $BLOCK)"
        echo "✓ Address and ABI saved to {{deployments-file}}"
        # Copy to frontend
        FRONTEND_DIR="../pool-ui"
        if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
            cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
        fi
    else
        echo "⚠ Could not extract Verifier address from broadcast files."
        echo "Please check broadcast/DeployVerifier.s.sol/{{chain-id}}/run-latest.json"
    fi

# Deploy V4 artifacts locally (for Anvil)
# Usage: just deploy-v4 [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
deploy-v4 RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Check if V4 contracts are already deployed
    POOL_MGR=$(just _get-address poolManager)
    POS_MGR=$(just _get-address positionManager)
    ROUTER=$(just _get-address router)
    
    # Known deterministic addresses for local Anvil (chainId 31337):
    if [ -z "$POOL_MGR" ]; then
        POOL_MGR="0x0D9BAf34817Fccd3b3068768E5d20542B66424A5"
    fi
    if [ -z "$POS_MGR" ]; then
        POS_MGR="0x90aAE8e3C8dF1d226431D0C2C7feAaa775fAF86C"
    fi
    if [ -z "$ROUTER" ]; then
        ROUTER="0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6"
    fi
    
    # Extract RPC_URL first for the check
    RPC_VAL_CHECK="{{RPC_URL}}"
    case "$RPC_VAL_CHECK" in
        RPC_URL=*)
            RPC_VAL_CHECK="${RPC_VAL_CHECK#RPC_URL=}"
            ;;
    esac
    RPC_VAL_CHECK=$(echo "$RPC_VAL_CHECK" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Check if contracts have code at these addresses
    CODE_PM=$(cast code "$POOL_MGR" --rpc-url "$RPC_VAL_CHECK" 2>/dev/null || echo "")
    CODE_POS=$(cast code "$POS_MGR" --rpc-url "$RPC_VAL_CHECK" 2>/dev/null || echo "")
    CODE_RTR=$(cast code "$ROUTER" --rpc-url "$RPC_VAL_CHECK" 2>/dev/null || echo "")
    if [ -n "$CODE_PM" ] && [ -n "$CODE_POS" ] && [ -n "$CODE_RTR" ] && \
       [ "$CODE_PM" != "0x" ] && [ "$CODE_POS" != "0x" ] && [ "$CODE_RTR" != "0x" ]; then
        # Save addresses if not already saved
        [ -z "$(just _get-address poolManager)" ] && just _set-address poolManager "$POOL_MGR"
        [ -z "$(just _get-address positionManager)" ] && just _set-address positionManager "$POS_MGR"
        [ -z "$(just _get-address router)" ] && just _set-address router "$ROUTER"
        echo "✓ V4 contracts already deployed:"
        echo "  PoolManager: $POOL_MGR"
        echo "  PositionManager: $POS_MGR"
        echo "  Router: $ROUTER"
        echo "Skipping V4 deployment."
        # Copy to frontend
        FRONTEND_DIR="../pool-ui"
        if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
            cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
        fi
        exit 0
    fi
    
    # Extract and clean parameters
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    ACCOUNT_VAL="{{ACCOUNT}}"
    SENDER_VAL="{{SENDER}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    case "$ACCOUNT_VAL" in
        ACCOUNT=*)
            ACCOUNT_VAL="${ACCOUNT_VAL#ACCOUNT=}"
            ;;
    esac
    case "$SENDER_VAL" in
        SENDER=*)
            SENDER_VAL="${SENDER_VAL#SENDER=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    ACCOUNT_VAL=$(echo "$ACCOUNT_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    SENDER_VAL=$(echo "$SENDER_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    echo "Deploying V4 artifacts to local network..."
    # Build command array
    CMD_ARGS=("script/testing/00_DeployV4.s.sol" "--rpc-url" "$RPC_VAL")
    
    # Only add --private-key if provided and not empty
    if [ -n "$PK_VAL" ] && [ "$PK_VAL" != "" ]; then
        CMD_ARGS+=("--private-key" "$PK_VAL")
    fi
    
    # Only add --account if provided, not empty, and not "default"
    if [ -n "$ACCOUNT_VAL" ] && [ "$ACCOUNT_VAL" != "" ] && [ "$ACCOUNT_VAL" != "default" ]; then
        CMD_ARGS+=("--account" "$ACCOUNT_VAL")
    fi
    
    # Only add --sender if provided and not empty
    if [ -n "$SENDER_VAL" ] && [ "$SENDER_VAL" != "" ] && [ "$SENDER_VAL" != "''" ]; then
        CMD_ARGS+=("--sender" "$SENDER_VAL")
    fi
    
    CMD_ARGS+=(--broadcast)
    
    forge script "${CMD_ARGS[@]}"
    
    # Extract addresses from broadcast JSON
    echo ""
    echo "Extracting V4 addresses from broadcast files..."
    BROADCAST_FILE="broadcast/00_DeployV4.s.sol/{{chain-id}}/run-latest.json"
    
    # V4 contracts have null contractName, so we identify them by their deterministic addresses
    # Convert addresses to lowercase for comparison
    POOL_MGR=$(jq -r '.transactions[] | select(.contractAddress != null) | select((.contractAddress | ascii_downcase) == "0x0d9baf34817fccd3b3068768e5d20542b66424a5") | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "")
    POS_MGR=$(jq -r '.transactions[] | select(.contractAddress != null) | select((.contractAddress | ascii_downcase) == "0x90aae8e3c8df1d226431d0c2c7feaaa775faf86c") | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "")
    ROUTER=$(jq -r '.transactions[] | select(.contractAddress != null) | select((.contractAddress | ascii_downcase) == "0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6") | .contractAddress' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "")
    
    # Fallback: use known deterministic addresses for local Anvil
    if [ -z "$POOL_MGR" ]; then
        POOL_MGR="0x0D9BAf34817Fccd3b3068768E5d20542B66424A5"
    fi
    if [ -z "$POS_MGR" ]; then
        POS_MGR="0x90aAE8e3C8dF1d226431D0C2C7feAaa775fAF86C"
    fi
    if [ -z "$ROUTER" ]; then
        ROUTER="0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6"
    fi
    
    # Extract block numbers (V4 contracts are deployed in same transaction, so use first receipt)
    BLOCK=$(jq -r '.receipts[0].blockNumber' "$BROADCAST_FILE" 2>/dev/null || echo "0")
    BLOCK=$(printf "%d" "$BLOCK" 2>/dev/null || echo "0")
    
    # Note: V4 contracts are from external libraries, so we may not have ABIs locally
    # Save addresses with block numbers (ABI will be empty array)
    just _set-contract-metadata poolManager "$POOL_MGR" "" "$BLOCK"
    just _set-contract-metadata positionManager "$POS_MGR" "" "$BLOCK"
    just _set-contract-metadata router "$ROUTER" "" "$BLOCK"
    echo ""
    echo "✓ PoolManager: $POOL_MGR (block: $BLOCK)"
    echo "✓ PositionManager: $POS_MGR (block: $BLOCK)"
    echo "✓ Router: $ROUTER (block: $BLOCK)"
    echo "✓ Addresses saved to {{deployments-file}}"
    echo "  Note: V4 contract ABIs are in external libraries (uniswap-hooks, hookmate)"
    # Copy to frontend
    FRONTEND_DIR="../pool-ui"
    if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
        cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
    fi

# ============================================================================
# Pool Management Commands
# ============================================================================

# Create a new pool and add initial liquidity
# Usage: just create-pool [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
create-pool RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Load all addresses from deployments.json
    eval "$(just _load-addresses)"
    
    # Check required addresses
    if [ -z "$HOOK_ADDRESS" ]; then
        echo "Error: HOOK_ADDRESS not found in {{deployments-file}}"
        echo "Please run 'just deploy-hook' first"
        exit 1
    fi
    
    echo "Using addresses from {{deployments-file}}:"
    echo "  Hook: $HOOK_ADDRESS"
    [ -n "$TOKEN0_ADDRESS" ] && echo "  Token0: $TOKEN0_ADDRESS"
    [ -n "$TOKEN1_ADDRESS" ] && echo "  Token1: $TOKEN1_ADDRESS"
    [ -n "$POOL_MANAGER_ADDRESS" ] && echo "  PoolManager: $POOL_MANAGER_ADDRESS"
    
    # Extract and clean parameters
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    ACCOUNT_VAL="{{ACCOUNT}}"
    SENDER_VAL="{{SENDER}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    case "$ACCOUNT_VAL" in
        ACCOUNT=*)
            ACCOUNT_VAL="${ACCOUNT_VAL#ACCOUNT=}"
            ;;
    esac
    case "$SENDER_VAL" in
        SENDER=*)
            SENDER_VAL="${SENDER_VAL#SENDER=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    ACCOUNT_VAL=$(echo "$ACCOUNT_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    SENDER_VAL=$(echo "$SENDER_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    echo "Creating pool with hook: $HOOK_ADDRESS"
    # Build command array
    CMD_ARGS=("script/01_CreatePoolAndAddLiquidity.s.sol" "--rpc-url" "$RPC_VAL")
    
    # Only add --private-key if provided and not empty
    if [ -n "$PK_VAL" ] && [ "$PK_VAL" != "" ]; then
        CMD_ARGS+=("--private-key" "$PK_VAL")
    fi
    
    # Only add --account if provided, not empty, and not "default"
    if [ -n "$ACCOUNT_VAL" ] && [ "$ACCOUNT_VAL" != "" ] && [ "$ACCOUNT_VAL" != "default" ]; then
        CMD_ARGS+=("--account" "$ACCOUNT_VAL")
    fi
    
    # Only add --sender if provided and not empty
    if [ -n "$SENDER_VAL" ] && [ "$SENDER_VAL" != "" ] && [ "$SENDER_VAL" != "''" ]; then
        CMD_ARGS+=("--sender" "$SENDER_VAL")
    fi
    
    CMD_ARGS+=(--broadcast)
    
    forge script "${CMD_ARGS[@]}"

# Add liquidity to an existing pool
# Usage: just add-liquidity [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
add-liquidity RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Load all addresses from deployments.json
    eval "$(just _load-addresses)"
    
    if [ -z "$HOOK_ADDRESS" ]; then
        echo "Error: HOOK_ADDRESS not found in {{deployments-file}}"
        echo "Please run 'just deploy-hook' first"
        exit 1
    fi
    
    RPC_ARG="--rpc-url {{RPC_URL}}"
    PRIVATE_KEY_ARG=""
    ACCOUNT_ARG=""
    SENDER_ARG=""
    
    # Use private key for local Anvil, or account for other networks
    PRIVATE_KEY_VAL="{{PRIVATE_KEY}}"
    if [ -n "$PRIVATE_KEY_VAL" ] && [ "$PRIVATE_KEY_VAL" != "" ]; then
        PRIVATE_KEY_ARG="--private-key $PRIVATE_KEY_VAL"
    fi
    
    # Only use --account if explicitly provided and not "default"
    if [ -n "{{ACCOUNT}}" ] && [ "{{ACCOUNT}}" != "default" ] && [ "{{ACCOUNT}}" != "" ]; then
        ACCOUNT_ARG="--account {{ACCOUNT}}"
    fi
    
    if [ -n "{{SENDER}}" ] && [ "{{SENDER}}" != "''" ] && [ "{{SENDER}}" != "" ]; then
        SENDER_ARG="--sender {{SENDER}}"
    fi
    
    echo "Adding liquidity to pool with hook: $HOOK_ADDRESS"
    forge script script/02_AddLiquidity.s.sol \
        $RPC_ARG \
        $PRIVATE_KEY_ARG \
        $ACCOUNT_ARG \
        $SENDER_ARG \
        --broadcast

# ============================================================================
# Swap Commands
# ============================================================================

# Execute a regular swap
# Usage: just swap [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
swap RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Load all addresses from deployments.json
    eval "$(just _load-addresses)"
    
    if [ -z "$HOOK_ADDRESS" ]; then
        echo "Error: HOOK_ADDRESS not found in {{deployments-file}}"
        echo "Please run 'just deploy-hook' first"
        exit 1
    fi
    
    RPC_ARG="--rpc-url {{RPC_URL}}"
    PRIVATE_KEY_ARG=""
    ACCOUNT_ARG=""
    SENDER_ARG=""
    
    # Use private key for local Anvil, or account for other networks
    PRIVATE_KEY_VAL="{{PRIVATE_KEY}}"
    if [ -n "$PRIVATE_KEY_VAL" ] && [ "$PRIVATE_KEY_VAL" != "" ]; then
        PRIVATE_KEY_ARG="--private-key $PRIVATE_KEY_VAL"
    fi
    
    # Only use --account if explicitly provided and not "default"
    if [ -n "{{ACCOUNT}}" ] && [ "{{ACCOUNT}}" != "default" ] && [ "{{ACCOUNT}}" != "" ]; then
        ACCOUNT_ARG="--account {{ACCOUNT}}"
    fi
    
    if [ -n "{{SENDER}}" ] && [ "{{SENDER}}" != "''" ] && [ "{{SENDER}}" != "" ]; then
        SENDER_ARG="--sender {{SENDER}}"
    fi
    
    echo "Executing swap with hook: $HOOK_ADDRESS"
    forge script script/03_Swap.s.sol \
        $RPC_ARG \
        $PRIVATE_KEY_ARG \
        $ACCOUNT_ARG \
        $SENDER_ARG \
        --broadcast

# Execute a swap with commitment hash for RPS game
# Usage: just swap-rps COMMITMENT_HASH [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
swap-rps COMMITMENT_HASH RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    if [ -z "{{COMMITMENT_HASH}}" ]; then
        echo "Error: COMMITMENT_HASH is required"
        echo "Usage: just swap-rps <COMMITMENT_HASH> [RPC_URL=...] [ACCOUNT=...] [SENDER=...]"
        exit 1
    fi
    
    # Load all addresses from deployments.json
    eval "$(just _load-addresses)"
    
    if [ -z "$HOOK_ADDRESS" ]; then
        echo "Error: HOOK_ADDRESS not found in {{deployments-file}}"
        echo "Please run 'just deploy-hook' first"
        exit 1
    fi
    
    RPC_ARG="--rpc-url {{RPC_URL}}"
    PRIVATE_KEY_ARG=""
    ACCOUNT_ARG=""
    SENDER_ARG=""
    
    # Use private key for local Anvil
    PRIVATE_KEY_VAL="{{PRIVATE_KEY}}"
    if [ -n "$PRIVATE_KEY_VAL" ] && [ "$PRIVATE_KEY_VAL" != "" ]; then
        PRIVATE_KEY_ARG="--private-key"
        PRIVATE_KEY_VALUE="$PRIVATE_KEY_VAL"
    fi
    
    # Only use --account if explicitly provided
    ACCOUNT_VAL="{{ACCOUNT}}"
    if [ -n "$ACCOUNT_VAL" ] && [ "$ACCOUNT_VAL" != "default" ] && [ "$ACCOUNT_VAL" != "" ]; then
        ACCOUNT_ARG="--account"
        ACCOUNT_VALUE="$ACCOUNT_VAL"
    fi
    
    SENDER_VAL="{{SENDER}}"
    if [ -n "$SENDER_VAL" ] && [ "$SENDER_VAL" != "''" ] && [ "$SENDER_VAL" != "" ]; then
        SENDER_ARG="--sender"
        SENDER_VALUE="$SENDER_VAL"
    fi
    
    export COMMITMENT_HASH={{COMMITMENT_HASH}}
    
    echo "Executing RPS swap with commitment: {{COMMITMENT_HASH}}"
    echo "Hook address: $HOOK_ADDRESS"
    # Build command array
    CMD_ARGS=("script/03_Swap.s.sol" $RPC_ARG)
    [ -n "$PRIVATE_KEY_ARG" ] && CMD_ARGS+=($PRIVATE_KEY_ARG "$PRIVATE_KEY_VALUE")
    [ -n "$ACCOUNT_ARG" ] && CMD_ARGS+=($ACCOUNT_ARG "$ACCOUNT_VALUE")
    [ -n "$SENDER_ARG" ] && CMD_ARGS+=($SENDER_ARG "$SENDER_VALUE")
    CMD_ARGS+=(--broadcast)
    
    forge script "${CMD_ARGS[@]}"

# ============================================================================
# Development & Testing Commands
# ============================================================================

# Run all tests
test:
    forge test

# Run tests with verbosity
test-verbose:
    forge test -vvv

# Run specific test file
test-file FILE:
    forge test --match-path {{FILE}}

# Build the project
build:
    forge build

# Clean build artifacts
clean:
    forge clean

# Format code
fmt:
    forge fmt

# ============================================================================
# Complete Workflow Commands
# ============================================================================

# Complete setup: deploy V4 infrastructure, tokens, hook, verifier, RockPaperScissors, create pool, and add initial liquidity
# Usage: just setup [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
setup RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Store parameters in variables to avoid expansion issues
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    ACCOUNT_VAL="{{ACCOUNT}}"
    SENDER_VAL="{{SENDER}}"
    
    echo "=== Step 1: Deploying Tokens ==="
    just deploy-tokens RPC_URL="$RPC_VAL" PRIVATE_KEY="$PK_VAL"
    
    echo ""
    echo "=== Step 2: Deploying V4 Infrastructure ==="
    just deploy-v4 RPC_URL="$RPC_VAL" PRIVATE_KEY="$PK_VAL" ACCOUNT="$ACCOUNT_VAL" SENDER="$SENDER_VAL"
    
    echo ""
    echo "=== Step 3: Deploying Hook ==="
    just deploy-hook RPC_URL="$RPC_VAL" PRIVATE_KEY="$PK_VAL" ACCOUNT="$ACCOUNT_VAL" SENDER="$SENDER_VAL"
    
    echo ""
    echo "=== Step 4: Deploying SenderRelayRouter ==="
    just deploy-relay-router RPC_URL="$RPC_VAL" PRIVATE_KEY="$PK_VAL" ACCOUNT="$ACCOUNT_VAL" SENDER="$SENDER_VAL"
    
    echo ""
    echo "=== Step 5: Deploying Verifier ==="
    just deploy-verifier RPC_URL="$RPC_VAL" PRIVATE_KEY="$PK_VAL" ACCOUNT="$ACCOUNT_VAL" SENDER="$SENDER_VAL"
    
    echo ""
    echo "=== Step 6: Deploying RockPaperScissors ==="
    just deploy-rps RPC_URL="$RPC_VAL" PRIVATE_KEY="$PK_VAL" ACCOUNT="$ACCOUNT_VAL" SENDER="$SENDER_VAL"
    
    echo ""
    echo "=== Step 7: Configuring Hook with RockPaperScissors ==="
    just configure-hook RPC_URL="$RPC_VAL" PRIVATE_KEY="$PK_VAL" ACCOUNT="$ACCOUNT_VAL" SENDER="$SENDER_VAL"
    
    echo ""
    echo "=== Step 8: Creating Pool and Adding Liquidity ==="
    just create-pool RPC_URL="$RPC_VAL" PRIVATE_KEY="$PK_VAL" ACCOUNT="$ACCOUNT_VAL" SENDER="$SENDER_VAL"
    
    echo ""
    echo "✓ Setup complete!"
    echo ""
    echo "Deployed addresses:"
    just show-addresses
    echo ""
    # Copy deployments.json to frontend
    FRONTEND_DIR="../frontend"
    if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
        cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
    else
        echo "⚠️  Note: Frontend directory not found at $FRONTEND_DIR, skipping sync."
    fi
    echo ""
    echo "⚠️  IMPORTANT: The frontend will use SenderRelayRouter for token approvals."
    echo "   Make sure to approve tokens to the SenderRelayRouter address, not the base router!"

# ============================================================================
# Utility Commands
# ============================================================================

# Show current configuration
status:
    #!/usr/bin/env bash
    echo "=== Current Configuration ==="
    echo ""
    
    if [ -f {{deployments-file}} ]; then
        echo "Deployed Contracts:"
        cat {{deployments-file}} | jq '.'
    else
        echo "No deployments found."
    fi
    
    echo ""
    echo "Default RPC URL: {{default-rpc-url}}"
    echo "Default Account: {{default-account}}"
    echo ""
    echo "To override defaults, use environment variables:"
    echo "  export RPC_URL=<your-rpc-url>"
    echo "  export ACCOUNT=<your-account-name>"
    echo "  export SENDER=<your-sender-address>"

# Clear all saved addresses
clear-addresses:
    rm -f {{deployments-file}}
    echo "Cleared all saved addresses"

# Fund an address with 10 ETH
# Usage: just fund [ADDRESS=0x2f04d60991191005103d73bdcf12187a824d42a4] [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
fund ADDRESS="0x2f04d60991191005103d73bdcf12187a824d42a4" RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80":
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters
    ADDR_VAL="{{ADDRESS}}"
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    
    # Strip parameter name prefix if present
    case "$ADDR_VAL" in
        ADDRESS=*)
            ADDR_VAL="${ADDR_VAL#ADDRESS=}"
            ;;
    esac
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    
    # Remove quotes and trim
    ADDR_VAL=$(echo "$ADDR_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Validate address format
    if [ -z "$ADDR_VAL" ] || [ "${#ADDR_VAL}" -ne 42 ] || [ "${ADDR_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid address format. Expected 42 characters starting with 0x"
        echo "Got: [$ADDR_VAL] (length: ${#ADDR_VAL})"
        exit 1
    fi
    
    # Validate private key format
    if [ -z "$PK_VAL" ] || [ "${#PK_VAL}" -ne 66 ] || [ "${PK_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid private key format. Expected 66 characters starting with 0x"
        echo "Got: [$PK_VAL] (length: ${#PK_VAL})"
        exit 1
    fi
    
    echo "Funding address $ADDR_VAL with 10 ETH..."
    cast send "$ADDR_VAL" \
        --value 10ether \
        --private-key "$PK_VAL" \
        --rpc-url "$RPC_VAL"
    
    echo ""
    echo "✓ Successfully sent 10 ETH to $ADDR_VAL"

# Mint 1000 token0 to an address
# Usage: just mint-token0 [ADDRESS=0x2f04d60991191005103d73bdcf12187a824d42a4] [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
mint-token0 ADDRESS="0x2f04d60991191005103d73bdcf12187a824d42a4" RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80":
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters
    ADDR_VAL="{{ADDRESS}}"
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    
    # Strip parameter name prefix if present
    case "$ADDR_VAL" in
        ADDRESS=*)
            ADDR_VAL="${ADDR_VAL#ADDRESS=}"
            ;;
    esac
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    
    # Remove quotes and trim
    ADDR_VAL=$(echo "$ADDR_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Validate address format
    if [ -z "$ADDR_VAL" ] || [ "${#ADDR_VAL}" -ne 42 ] || [ "${ADDR_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid address format. Expected 42 characters starting with 0x"
        echo "Got: [$ADDR_VAL] (length: ${#ADDR_VAL})"
        exit 1
    fi
    
    # Validate private key format
    if [ -z "$PK_VAL" ] || [ "${#PK_VAL}" -ne 66 ] || [ "${PK_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid private key format. Expected 66 characters starting with 0x"
        echo "Got: [$PK_VAL] (length: ${#PK_VAL})"
        exit 1
    fi
    
    # Get token0 address from deployments.json
    TOKEN0=$(just _get-address token0)
    if [ -z "$TOKEN0" ]; then
        echo "Error: token0 address not found in {{deployments-file}}"
        echo "Please run 'just deploy-tokens' first"
        exit 1
    fi
    
    echo "Minting 1000 token0 to $ADDR_VAL..."
    cast send "$TOKEN0" \
        "mint(address,uint256)" "$ADDR_VAL" "1000e18" \
        --private-key "$PK_VAL" \
        --rpc-url "$RPC_VAL"
    
    echo ""
    echo "✓ Successfully minted 1000 token0 to $ADDR_VAL"

# Mint 1000 token1 to an address
# Usage: just mint-token1 [ADDRESS=0x2f04d60991191005103d73bdcf12187a824d42a4] [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
mint-token1 ADDRESS="0x2f04d60991191005103d73bdcf12187a824d42a4" RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80":
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters
    ADDR_VAL="{{ADDRESS}}"
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    
    # Strip parameter name prefix if present
    case "$ADDR_VAL" in
        ADDRESS=*)
            ADDR_VAL="${ADDR_VAL#ADDRESS=}"
            ;;
    esac
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    
    # Remove quotes and trim
    ADDR_VAL=$(echo "$ADDR_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Validate address format
    if [ -z "$ADDR_VAL" ] || [ "${#ADDR_VAL}" -ne 42 ] || [ "${ADDR_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid address format. Expected 42 characters starting with 0x"
        echo "Got: [$ADDR_VAL] (length: ${#ADDR_VAL})"
        exit 1
    fi
    
    # Validate private key format
    if [ -z "$PK_VAL" ] || [ "${#PK_VAL}" -ne 66 ] || [ "${PK_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid private key format. Expected 66 characters starting with 0x"
        echo "Got: [$PK_VAL] (length: ${#PK_VAL})"
        exit 1
    fi
    
    # Get token1 address from deployments.json
    TOKEN1=$(just _get-address token1)
    if [ -z "$TOKEN1" ]; then
        echo "Error: token1 address not found in {{deployments-file}}"
        echo "Please run 'just deploy-tokens' first"
        exit 1
    fi
    
    echo "Minting 1000 token1 to $ADDR_VAL..."
    cast send "$TOKEN1" \
        "mint(address,uint256)" "$ADDR_VAL" "1000e18" \
        --private-key "$PK_VAL" \
        --rpc-url "$RPC_VAL"
    
    echo ""
    echo "✓ Successfully minted 1000 token1 to $ADDR_VAL"

# Mint 1000 of each token (token0 and token1) to an address
# Usage: just mint-tokens [ADDRESS=0x2f04d60991191005103d73bdcf12187a824d42a4] [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
mint-tokens ADDRESS="0x2f04d60991191005103d73bdcf12187a824d42a4" RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80":
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters
    ADDR_VAL="{{ADDRESS}}"
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    
    # Strip parameter name prefix if present
    case "$ADDR_VAL" in
        ADDRESS=*)
            ADDR_VAL="${ADDR_VAL#ADDRESS=}"
            ;;
    esac
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    
    # Remove quotes and trim
    ADDR_VAL=$(echo "$ADDR_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Validate address format
    if [ -z "$ADDR_VAL" ] || [ "${#ADDR_VAL}" -ne 42 ] || [ "${ADDR_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid address format. Expected 42 characters starting with 0x"
        echo "Got: [$ADDR_VAL] (length: ${#ADDR_VAL})"
        exit 1
    fi
    
    # Validate private key format
    if [ -z "$PK_VAL" ] || [ "${#PK_VAL}" -ne 66 ] || [ "${PK_VAL:0:2}" != "0x" ]; then
        echo "Error: Invalid private key format. Expected 66 characters starting with 0x"
        echo "Got: [$PK_VAL] (length: ${#PK_VAL})"
        exit 1
    fi
    
    # Get token addresses from deployments.json
    TOKEN0=$(just _get-address token0)
    TOKEN1=$(just _get-address token1)
    
    if [ -z "$TOKEN0" ]; then
        echo "Error: token0 address not found in {{deployments-file}}"
        echo "Please run 'just deploy-tokens' first"
        exit 1
    fi
    
    if [ -z "$TOKEN1" ]; then
        echo "Error: token1 address not found in {{deployments-file}}"
        echo "Please run 'just deploy-tokens' first"
        exit 1
    fi
    
    echo "Minting 1000 token0 to $ADDR_VAL..."
    cast send "$TOKEN0" \
        "mint(address,uint256)" "$ADDR_VAL" "1000e18" \
        --private-key "$PK_VAL" \
        --rpc-url "$RPC_VAL"
    
    echo ""
    echo "Minting 1000 token1 to $ADDR_VAL..."
    cast send "$TOKEN1" \
        "mint(address,uint256)" "$ADDR_VAL" "1000e18" \
        --private-key "$PK_VAL" \
        --rpc-url "$RPC_VAL"
    
    echo ""
    echo "✓ Successfully minted 1000 token0 and 1000 token1 to $ADDR_VAL"

# Deploy SenderRelayRouter wrapper
# Usage: just deploy-relay-router [RPC_URL=http://localhost:8545] [PRIVATE_KEY=0x...]
deploy-relay-router RPC_URL="http://localhost:8545" PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" ACCOUNT='' SENDER='':
    #!/usr/bin/env bash
    set -e
    
    # Load all addresses from deployments.json
    eval "$(just _load-addresses)"
    
    if [ -z "$ROUTER_ADDRESS" ]; then
        echo "Error: ROUTER_ADDRESS not found in {{deployments-file}}"
        echo "Please run 'just deploy-v4' first"
        exit 1
    fi
    
    # Extract and clean parameters
    RPC_VAL="{{RPC_URL}}"
    PK_VAL="{{PRIVATE_KEY}}"
    ACCOUNT_VAL="{{ACCOUNT}}"
    SENDER_VAL="{{SENDER}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$PK_VAL" in
        PRIVATE_KEY=*)
            PK_VAL="${PK_VAL#PRIVATE_KEY=}"
            ;;
    esac
    case "$ACCOUNT_VAL" in
        ACCOUNT=*)
            ACCOUNT_VAL="${ACCOUNT_VAL#ACCOUNT=}"
            ;;
    esac
    case "$SENDER_VAL" in
        SENDER=*)
            SENDER_VAL="${SENDER_VAL#SENDER=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    PK_VAL=$(echo "$PK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    ACCOUNT_VAL=$(echo "$ACCOUNT_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    SENDER_VAL=$(echo "$SENDER_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    export ROUTER_ADDRESS=$ROUTER_ADDRESS
    
    echo "Deploying SenderRelayRouter..."
    echo "Base router: $ROUTER_ADDRESS"
    
    # Build command array
    CMD_ARGS=("script/05_DeploySenderRelayRouter.s.sol" "--rpc-url" "$RPC_VAL")
    
    # Only add --private-key if provided and not empty
    if [ -n "$PK_VAL" ] && [ "$PK_VAL" != "" ]; then
        CMD_ARGS+=("--private-key" "$PK_VAL")
    fi
    
    # Only add --account if provided, not empty, and not "default"
    if [ -n "$ACCOUNT_VAL" ] && [ "$ACCOUNT_VAL" != "" ] && [ "$ACCOUNT_VAL" != "default" ]; then
        CMD_ARGS+=("--account" "$ACCOUNT_VAL")
    fi
    
    # Only add --sender if provided and not empty
    if [ -n "$SENDER_VAL" ] && [ "$SENDER_VAL" != "" ] && [ "$SENDER_VAL" != "''" ]; then
        CMD_ARGS+=("--sender" "$SENDER_VAL")
    fi
    
    CMD_ARGS+=(--broadcast)
    
    forge script "${CMD_ARGS[@]}"
    
    # Extract SenderRelayRouter address from broadcast JSON
    echo ""
    echo "Extracting SenderRelayRouter address from broadcast files..."
    RELAY_ROUTER_ADDR=$(just _extract-from-broadcast 05_DeploySenderRelayRouter.s.sol SenderRelayRouter)
    
    if [ -n "$RELAY_ROUTER_ADDR" ]; then
        # Extract block number
        BROADCAST_FILE="broadcast/05_DeploySenderRelayRouter.s.sol/{{chain-id}}/run-latest.json"
        HASH=$(jq -r '.transactions[] | select(.contractName == "SenderRelayRouter" and .contractAddress == "'"$RELAY_ROUTER_ADDR"'") | .hash' "$BROADCAST_FILE" 2>/dev/null | head -1)
        BLOCK=$(jq -r --arg hash "$HASH" '.receipts[] | select(.transactionHash == $hash) | .blockNumber' "$BROADCAST_FILE" 2>/dev/null | head -1 || echo "0x0")
        BLOCK=$(printf "%d" "$BLOCK" 2>/dev/null || echo "0")
        
        # Save with metadata
        just _set-contract-metadata senderRelayRouter "$RELAY_ROUTER_ADDR" "out/SenderRelayRouter.sol/SenderRelayRouter.json" "$BLOCK"
        echo ""
        echo "✓ SenderRelayRouter deployed at: $RELAY_ROUTER_ADDR (block: $BLOCK)"
        echo "✓ Address and ABI saved to {{deployments-file}}"
        echo ""
        echo "⚠️  IMPORTANT: Update your frontend to use this address for token approvals!"
        echo "   The frontend should approve tokens to: $RELAY_ROUTER_ADDR"
        echo "   (not the base router at $ROUTER_ADDRESS)"
        # Copy to frontend
        FRONTEND_DIR="../pool-ui"
        if [ -d "$FRONTEND_DIR" ] && [ -f {{deployments-file}} ]; then
            cp {{deployments-file}} "$FRONTEND_DIR/" && echo "✓ Copied {{deployments-file}} to $FRONTEND_DIR/"
        fi
    else
        echo "⚠ Could not extract SenderRelayRouter address from broadcast files."
        echo "Please check broadcast/05_DeploySenderRelayRouter.s.sol/{{chain-id}}/run-latest.json"
    fi

# ============================================================================
# Query Commands
# ============================================================================

# Query the hook contract and fetch all currently open games
# Usage: just query-games [RPC_URL=http://localhost:8545] [FROM_BLOCK=0]
query-games RPC_URL="http://localhost:8545" FROM_BLOCK="0":
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters
    RPC_VAL="{{RPC_URL}}"
    FROM_BLOCK_VAL="{{FROM_BLOCK}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    case "$FROM_BLOCK_VAL" in
        FROM_BLOCK=*)
            FROM_BLOCK_VAL="${FROM_BLOCK_VAL#FROM_BLOCK=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    FROM_BLOCK_VAL=$(echo "$FROM_BLOCK_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Get hook address from deployments.json
    HOOK_ADDR=$(just _get-address hook)
    if [ -z "$HOOK_ADDR" ]; then
        echo "Error: hook address not found in {{deployments-file}}"
        echo "Please run 'just deploy-hook' first"
        exit 1
    fi
    
    echo "=== Querying Active Games ==="
    echo "Hook Address: $HOOK_ADDR"
    echo "RPC URL: $RPC_VAL"
    echo ""
    
    # Query the contract directly for active games
    echo "Querying contract for active games..."
    
    # Get count of active games
    ACTIVE_COUNT=$(cast call "$HOOK_ADDR" \
        "getActiveGamesCount()(uint256)" \
        --rpc-url "$RPC_VAL" 2>/dev/null || echo "0")
    
    # Remove "uint256:" prefix if present
    ACTIVE_COUNT=$(echo "$ACTIVE_COUNT" | sed 's/uint256://' | xargs)
    
    if [ -z "$ACTIVE_COUNT" ] || [ "$ACTIVE_COUNT" = "0" ]; then
        echo "No active games found."
        exit 0
    fi
    
    echo "Found $ACTIVE_COUNT active game(s)"
    echo ""
    
    # Get all active games
    ACTIVE_GAMES=$(cast call "$HOOK_ADDR" \
        "getAllActiveGames()(bytes32[])" \
        --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
    
    if [ -z "$ACTIVE_GAMES" ]; then
        echo "Error: Could not retrieve active games from contract."
        exit 1
    fi
    
    # Extract commitment hashes from the array
    # cast outputs arrays in a specific format, we need to parse it
    UNIQUE_HASHES=$(echo "$ACTIVE_GAMES" | grep -oE '0x[a-fA-F0-9]{64}' || echo "")
    
    if [ -z "$UNIQUE_HASHES" ]; then
        echo "No active games found."
        exit 0
    fi
    
    # Query each commitment hash to check if it's still open
    OPEN_COUNT=0
    RESOLVED_COUNT=0
    REFUNDED_COUNT=0
    
    echo "Checking game status..."
    echo ""
    
    while IFS= read -r commitment_hash; do
        if [ -z "$commitment_hash" ]; then
            continue
        fi
        
        # Query getPendingSwap - returns a tuple with game data
        # The function signature is: getPendingSwap(bytes32)(address,uint256,bytes32,address,uint256,bool,address,uint8,uint256,uint256,bool,uint8,bytes32,bool)
        GAME_DATA=$(cast call "$HOOK_ADDR" \
            "getPendingSwap(bytes32)(address,uint256,bytes32,address,uint256,bool,address,uint8,uint256,uint256,bool,uint8,bytes32,bool)" \
            "$commitment_hash" \
            --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
        
        if [ -z "$GAME_DATA" ] || [ "$GAME_DATA" = "0x" ]; then
            # Game doesn't exist (might be refunded or resolved)
            continue
        fi
        
        # Parse the tuple - cast outputs tuples as a comma-separated list
        # Format: (address player1, uint256 timestamp, bytes32 poolId, address currency, uint256 player1Contribution, bool player2Moved, address player2, uint8 player2Move, uint256 player2Contribution, uint256 player2MoveTimestamp, bool revealed, uint8 player1Move, bytes32 salt, bool resolved)
        
        # Remove parentheses and split by comma
        CLEANED_DATA=$(echo "$GAME_DATA" | sed 's/^[()]*//;s/[()]*$//' | tr -d ' ')
        
        # Extract player1 (first address)
        PLAYER1=$(echo "$CLEANED_DATA" | grep -oE '0x[a-fA-F0-9]{40}' | head -1 || echo "")
        
        # Check if player1 is zero address (game doesn't exist)
        if [ -z "$PLAYER1" ] || [ "$PLAYER1" = "0x0000000000000000000000000000000000000000" ]; then
            continue
        fi
        
        # Use Python or a simpler approach to parse the tuple
        # For now, let's use a more reliable method with cast abi-decode
        # But first, let's try to extract key fields using pattern matching
        
        # Get all addresses in order
        ADDRS=($(echo "$GAME_DATA" | grep -oE '0x[a-fA-F0-9]{40}' || echo ""))
        PLAYER1="${ADDRS[0]}"
        if [ ${#ADDRS[@]} -gt 2 ]; then
            PLAYER2="${ADDRS[2]}"
        else
            PLAYER2=""
        fi
        
        # Get all booleans in order (player2Moved, revealed, resolved)
        BOOLS=($(echo "$GAME_DATA" | grep -oiE '(true|false)' || echo "false false false"))
        PLAYER2_MOVED="${BOOLS[0]:-false}"
        REVEALED="${BOOLS[1]:-false}"
        RESOLVED="${BOOLS[2]:-false}"
        
        # Get numeric values - contributions are at specific positions
        # We'll extract all numbers and use positional access
        NUMBERS=($(echo "$GAME_DATA" | grep -oE '[0-9]+' || echo "0 0 0 0"))
        # player1Contribution is typically the 2nd large number (after timestamp)
        # player2Contribution is typically the 4th large number
        # For simplicity, sum all contributions if we can't parse precisely
        PLAYER1_CONTRIB="${NUMBERS[1]:-0}"
        PLAYER2_CONTRIB="${NUMBERS[3]:-0}"
        
        # If parsing failed, try to get at least some info
        if [ -z "$PLAYER1_CONTRIB" ] || [ "$PLAYER1_CONTRIB" = "0" ]; then
            # Try alternative parsing
            PLAYER1_CONTRIB=$(echo "$GAME_DATA" | grep -oE 'player1Contribution[^0-9]*[0-9]+' | grep -oE '[0-9]+' | head -1 || echo "0")
        fi
        
        if [ "$RESOLVED" = "true" ]; then
            RESOLVED_COUNT=$((RESOLVED_COUNT + 1))
            continue
        fi
        
        # Game is open
        OPEN_COUNT=$((OPEN_COUNT + 1))
        
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Game #$OPEN_COUNT"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Commitment Hash: $commitment_hash"
        echo "Player 1:        $PLAYER1"
        echo "Status:          $(
            if [ "$REVEALED" = "true" ]; then
                echo "Revealed (resolved)"
            elif [ "$PLAYER2_MOVED" = "true" ]; then
                echo "Waiting for Player 1 to reveal"
            else
                echo "Waiting for Player 2"
            fi
        )"
        
        if [ "$PLAYER2_MOVED" = "true" ] && [ -n "$PLAYER2" ]; then
            echo "Player 2:        $PLAYER2"
        fi
        
        # Try to calculate prize pool, but don't fail if we can't parse contributions
        TOTAL_CONTRIB=$(echo "$PLAYER1_CONTRIB $PLAYER2_CONTRIB" | awk '{print $1+$2}' 2>/dev/null || echo "0")
        if [ "$TOTAL_CONTRIB" != "0" ] && [ -n "$TOTAL_CONTRIB" ]; then
            PRIZE_DISPLAY=$(cast --to-unit "$TOTAL_CONTRIB" ether 2>/dev/null || echo "$TOTAL_CONTRIB wei")
            echo "Prize Pool:      $PRIZE_DISPLAY"
        else
            echo "Prize Pool:      N/A (unable to parse)"
        fi
        echo ""
    done <<< "$UNIQUE_HASHES"
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Summary:"
    echo "  Open Games:    $OPEN_COUNT"
    echo "  Resolved:      $RESOLVED_COUNT"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    echo "✓ Query complete. All active games are shown above."

# Query games waiting for Player 2 (created by P1, not yet joined)
# Usage: just query-games-waiting [RPC_URL=http://localhost:8545]
query-games-waiting RPC_URL="http://localhost:8545":
    #!/usr/bin/env bash
    set -e
    
    # Extract and clean parameters
    RPC_VAL="{{RPC_URL}}"
    
    # Strip parameter name prefix if present
    case "$RPC_VAL" in
        RPC_URL=*)
            RPC_VAL="${RPC_VAL#RPC_URL=}"
            ;;
    esac
    
    # Remove quotes and trim
    RPC_VAL=$(echo "$RPC_VAL" | sed -e 's/^["'\'']*//' -e 's/["'\'']*$//' | xargs)
    
    # Get hook address from deployments.json
    HOOK_ADDR=$(just _get-address hook)
    if [ -z "$HOOK_ADDR" ]; then
        echo "Error: hook address not found in {{deployments-file}}"
        echo "Please run 'just deploy-hook' first"
        exit 1
    fi
    
    echo "=== Querying Games Waiting for Player 2 ==="
    echo "Hook Address: $HOOK_ADDR"
    echo "RPC URL: $RPC_VAL"
    echo ""
    
    # Query the contract for games waiting for Player 2
    WAITING_GAMES=$(cast call "$HOOK_ADDR" \
        "getGamesWaitingForPlayer2()(bytes32[])" \
        --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
    
    if [ -z "$WAITING_GAMES" ]; then
        echo "No games waiting for Player 2 found."
        exit 0
    fi
    
    # Extract commitment hashes
    HASHES=$(echo "$WAITING_GAMES" | grep -oE '0x[a-fA-F0-9]{64}' || echo "")
    
    if [ -z "$HASHES" ]; then
        echo "No games waiting for Player 2 found."
        exit 0
    fi
    
    COUNT=$(echo "$HASHES" | wc -l)
    echo "Found $COUNT game(s) waiting for Player 2:"
    echo ""
    
    GAME_NUM=0
    while IFS= read -r commitment_hash; do
        if [ -z "$commitment_hash" ]; then
            continue
        fi
        
        GAME_NUM=$((GAME_NUM + 1))
        
        # Query game details
        GAME_DATA=$(cast call "$HOOK_ADDR" \
            "getPendingSwap(bytes32)(address,uint256,bytes32,address,uint256,bool,address,uint8,uint256,uint256,bool,uint8,bytes32,bool)" \
            "$commitment_hash" \
            --rpc-url "$RPC_VAL" 2>/dev/null || echo "")
        
        if [ -z "$GAME_DATA" ] || [ "$GAME_DATA" = "0x" ]; then
            continue
        fi
        
        # Extract player1 and contribution
        ADDRS=($(echo "$GAME_DATA" | grep -oE '0x[a-fA-F0-9]{40}' || echo ""))
        PLAYER1="${ADDRS[0]}"
        NUMBERS=($(echo "$GAME_DATA" | grep -oE '[0-9]+' || echo "0"))
        PLAYER1_CONTRIB="${NUMBERS[1]:-0}"
        
        if [ -z "$PLAYER1" ] || [ "$PLAYER1" = "0x0000000000000000000000000000000000000000" ]; then
            continue
        fi
        
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Game #$GAME_NUM"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Commitment Hash: $commitment_hash"
        echo "Player 1:        $PLAYER1"
        echo "Status:          Waiting for Player 2"
        
        if [ -n "$PLAYER1_CONTRIB" ] && [ "$PLAYER1_CONTRIB" != "0" ]; then
            PRIZE_DISPLAY=$(cast --to-unit "$PLAYER1_CONTRIB" ether 2>/dev/null || echo "$PLAYER1_CONTRIB wei")
            echo "Prize Pool:      $PRIZE_DISPLAY (Player 1 contribution)"
        fi
        echo ""
    done <<< "$HASHES"
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Total: $GAME_NUM game(s) waiting for Player 2"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
